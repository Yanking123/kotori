一、nio.2中的基石Path
	Path表示文件系统中的路径，它仅仅表示路径从而与物理文件相分离开。Path表示的文件系统不仅仅是操作系统，而且可以表示一个jar或者zip文件系统。
  关键类：Path:路径；路径信息；路径转换；
         Paths:工具类。get()获取一个路径
         FileSystem:与文件系统交互的类
         FileSystems:工具类
eg:
        Path path = Paths.get("f:/Kotori/godev/src");//获取路径
//        FileSystems.getDefault().getPath("f:/Kotori/godev/src/hello.go");
        boolean directory = Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS);//是否是文件夹。忽略连接文件（快捷方式）
        System.out.println(directory);
        System.out.println(path.subpath(1,3));//截取路径，这里保留了第2和3索引的。（留尾不留首）
        System.out.println(path.getNameCount());//该路径中元素的个数；不含根元素。
        
        System.out.println(Paths.get("./src/cc/kotori/PathLearn1.java").normalize());//去除..或。生成路径
        System.out.println(Files.exists(Paths.get("./src/cc/kotori/PathLearn1.java"), LinkOption.NOFOLLOW_LINKS));//判断文件存在？
        
        System.out.println(Paths.get("./src/cc/kotori/PathLearn1.java").toRealPath(LinkOption.NOFOLLOW_LINKS));//获取真实路径
        
2.转换path ; 新旧io可以兼容使用
        path.toFile() : Path -> File
        file.toPath() : File -> Path
        
二、处理目录和目录树
1.在单个文件夹中查找文件
  DirectoryStream<Path> ds = Files.newDirectoryStream(path,"*.txt");
  依靠这个新api可以处理单个文件夹内的文件。第二个参数是glob表达式，提供了简单的文件过滤能力。
  eg: @Test
      public void test2()
      {
          Path path = Paths.get("f:/webapp/fac-dev-main-app");
          try(DirectoryStream<Path> ds = Files.newDirectoryStream(path)) //这里使用到了java7的新特性try-with-resource.
          {
              for(Path p : ds)
              {
                  System.out.println(p.getFileName());
              }
          }
          catch (IOException e)
          {
              e.printStackTrace();
          }
      }
  
2.操作目录树
  Files.walkFileTree(Path path, FileVisitor<? extends Path> visitor);
  jdk中已经提供了一个SimpleFileVisitor的实现类，现在要做的只是继承这个类，重写方法来处理我们的逻辑。
  出于安全性的考虑，walkFileTree这个方法不会去跟踪遍历符号连接，如果你想要跟随处理符号连接，就要判断文件属性，然后自己执行操作。
  eg: @Test
      public void test3()
      {
          Path path = Paths.get("f:/webapp/fac-dev-main-app");
          try
          {
              Files.walkFileTree(path, new MyPropertiesVisitor());
          }
          catch (IOException e)
          {
              e.printStackTrace();
          }

      }
      class MyPropertiesVisitor extends SimpleFileVisitor<Path>
      {

          @Override
          public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
                  throws IOException
          {
              if(file.toString().endsWith(".java"))
              {
                  System.out.println(file.getFileName());
              }
              return FileVisitResult.CONTINUE;
          }

      }
  其他的操作，如复制移动删除之类的也会变得很简单。
  
三、
